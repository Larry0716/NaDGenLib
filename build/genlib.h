#ifndef LARRY76_NADGENLIB_GENLIB_HEADER
#define LARRY76_NADGENLIB_GENLIB_HEADER

#include <cstdlib>
#include <cstdio>
#include <cstring>
#include <cassert>

#include <chrono>
#include <random>
#include <fstream>
#include <sstream>
#include <iomanip>
#include <iostream>
#include <string>
#include <algorithm>
#include <vector>
#include <map>

namespace Generator
{
	using std::string;
	std::ofstream *rout = nullptr;
	static string stdPath;
	static string nowFilename;
	static bool registeredStd = false;

	static void failed_to_execute()
	{
		fprintf(stderr, "\nFatal Error!!! Generator failed to continue executing!!!");
		*((int *)NULL) = 114514;
	}

	static void assertion_failed( const char *file,
	                              const char *base_file,
	                              const int line,
	                              const char *exp,
	                              const char *reason )
	{
		fprintf(stderr, "Assertion Failed!!\n");
		fprintf(stderr, "-> File: %s\n", file);
		fprintf(stderr, "-> Base File: %s\n", base_file);
		fprintf(stderr, "-> Line: %d\n", line);
		fprintf(stderr, "-> Expression: %s\n", exp);
		fprintf(stderr, "-> Information: %s\n", reason);
		failed_to_execute();
	}

#ifdef assert
#undef assert
#endif
#define assert(exp) if(!(exp)){ assertion_failed(__FILE__, __BASE_FILE__, __LINE__, #exp, NULL); }

#define asserti(exp,info) if(!(exp)){ assertion_failed(__FILE__, __BASE_FILE__, __LINE__, #exp, info); }

	static string FormatString(string buffer)
	{
		int i = 0;
		for(i = buffer.length()-1; i >= 0; --i) {
			if(buffer[i] == '.')
				break;
		}
		return buffer.substr(0, i);
	}

	/**
	 * @brief ?????????????
	 * @warning ?????????¨²??? AutoGenerate?????????¦Ê?????????????????¨²?????
	 * @warning ???????????????????? freopen ???????
	 * @param filename ?????????????????
	*/
	void RedirectToFileFunc(string filename)
	{
		if(rout != nullptr)
			delete rout;
		rout = new std::ofstream(filename);
		asserti(rout->is_open(), "Failed to open input file");
		nowFilename = filename;
	}

#define RedirectToFile(filename) RedirectToFileFunc(filename);\
	std::ofstream &cout = *rout;

#define FlushIOStream() std::ofstream &cout = *rout;


	/**
	 * @brief ?????????????
	 * @warning ????????????????????
	 * @warning ???????????????????????
	 * @warning ????????? AutoGenerate ???????????????????? AutoGenerate ?????????????
	 * @param path ???????¡¤????
	*/
	void RegisterStdProgram(string path)
	{
		asserti(!path.empty(), "Invalid std filepath");
		stdPath = path;
		registeredStd = true;
	}

	/**
	 * @brief ??????????????
	 * @warning ??????????????????
	 * @warning ????? AutoGenerate ??????Žï???§Ö?????
	 * @param ansFilename ??????????
	 * @param inputFilename ??????????????? RedirectToFile ???????????
	*/
	void GeneratreAns(string ansFilename, string inputFilename = nowFilename)
	{
		asserti(registeredStd, "No std program registered yet!!!");
		asserti(!inputFilename.empty(), "Invalid input filename!!! Maybe you haven\'t redirect to a file yet?");
		asserti(!ansFilename.empty(), "Invalid ans filename!!!");
		char buffer[2048];
		sprintf(buffer, "%s < %s > %s", stdPath.c_str(), inputFilename.c_str(), ansFilename.c_str());
		int ret = system(buffer);
		asserti(!ret, "Std program terminated unexpectedly");
	}

	/**
	 * @brief ????????????????????
	 * @param format ???????????????????
	 * @param startLabel ??????????
	 * @param endLabel ???????????
	 * @param custom ?????????????????????????????
	 * @param enableStd ???????????????????????????????????????????false????
	 * @warning ??????????????????????????????? %d??
	 * @warning ???????????????????????
	 * @warning ????????????????????????.ans
	*/
	void AutoGenerate( string format,
	                   int startLabel, int endLabel, void (*custom)(),
	                   bool enableStd = false )
	{
		char buffer[1024];
		char stdbuffer[1024];
		string stdFormat;
		if(enableStd) {
			asserti(registeredStd, "No std program registered yet!!");
			stdFormat = stdPath + " < %s > ";
			stdFormat += FormatString(format);
			stdFormat += ".ans";
		}
		time_t agcs = clock();
		for(int i=startLabel; i<=endLabel; i++) {
			sprintf(buffer, format.c_str(), i);
			RedirectToFileFunc(string(buffer));
			(*custom)();
			rout->close();
			if(enableStd) {
				sprintf(stdbuffer, stdFormat.c_str(), buffer, i);
				int ret = system(stdbuffer);
				asserti(!ret, "Std program terminated unexpectedly");
			}
		}
		time_t agce = clock();
		std::cerr << "AutoGenerate Used Time: " << agce-agcs << "ms." << std::endl;
	}

	/**
	 * @brief ??????????¨À?
	 * @param format ???????????????????
	 * @param startLabel ??????????
	 * @param endLabel ???????????
	 * @param custom ?????????????????????????????
	 * @param enableStd ???????????????????????????????????????????false????
	 * @warning ??????????????????????????????? %d??
	 * @warning ???????????????????????
	 * @warning ????????????????????????.ans
	*/
	void AutoGenerate( string format,
	                   int startLabel, int endLabel, void (*custom)(int nowLabel),
	                   bool enableStd = false )
	{
		char buffer[1024];
		char stdbuffer[1024];
		string stdFormat;
		if(enableStd) {
			asserti(registeredStd, "No std program registered yet!!");
			stdFormat = stdPath + " < %s > ";
			stdFormat += FormatString(format);
			stdFormat += ".ans";
		}
		time_t agcs = clock();
		for(int i=startLabel; i<=endLabel; i++) {
			sprintf(buffer, format.c_str(), i);
			RedirectToFileFunc(string(buffer));
			(*custom)(i);
			rout->close();
			if(enableStd) {
				sprintf(buffer, stdFormat.c_str(), buffer, i);
				int ret = system(stdbuffer);
				asserti(!ret, "Std program terminated unexpectedly");
			}
		}
		time_t agce = clock();
		std::cerr << "AutoGenerate Used Time: " << agce-agcs << "ms." << std::endl;
	}
}

namespace Generator
{
	using std::string;

	/**
	 * @brief ???????????????????????????????????????????????
	*/
	class Random
	{
		public:
			/**
			 * @brief Random ??????
			*/
			Random() {
				seed = std::chrono::system_clock::now().time_since_epoch().count();
				::srand(seed + (std::random_device {}()) + time(0) * ::rand());
				seed += ::rand();
				rand_int = new std::mt19937_64(seed);
				rand_real = new std::default_random_engine(seed);
			}
			/**
			 * @brief ?????????¦¶ [l,r] ??????
			 * @param l ???????§³?
			 * @param r ?????????
			 * @warning ????????????????????
			*/
			long long irand(long long l, long long r) {
				asserti(r>=l,"Invalid range");
				return (*rand_int)() % (r-l+1) + l;
			}
			/**
			 * @brief ?????????¦¶ [l,r] ???????
			 * @param l ???????§³?
			 * @param r ?????????
			*/
			long double frand(long double l, long double r) {
				asserti(r>=l, "Invalid range");
				static std::uniform_real_distribution<long double> dist(l, r);
				return dist(*rand_real);
			}
			/**
			 * @brief ??????????????????????????
			 * @param length ??????????????
			 * @param charset ??????????????????????§³§Õ
			*/
			string srand( unsigned long long length,
			              string charset="0123456789qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZMXNCBV" ) {
				string ans;
				while(length--)
					ans += charset[ irand(0, charset.length()-1) ];
				return ans;
			}
		private:
			std::mt19937_64 *rand_int;
			std::default_random_engine *rand_real;
			unsigned long long seed = 0;
	};
}

namespace Generator
{
	using std::string;
	extern std::ofstream *rout;

	enum SEQ_GEN_METHOD {
	    METHOD_INTEGER = 1,// ????????????
	    METHOD_FLOAT,// ?????????????
	    METHOD_CUSTOM//?????????????
	};

	/**
	 * @brief ???? Sequence ???????
	*/
	template <typename T = int>
	struct SEQ_GEN_CONF {
		SEQ_GEN_CONF() {}
		/**
		 * @brief SEQ_GEN_CONF ???????
		 * @param method ??????
		 * @param length ???????§Ô???
		 * @param vmin ???????§Ö???§³?
		 * @param vmax ???????§Ö?????
		 * @param split ???????§Ö?????????????
		 * @param ends ???????§Ö????????????????
		*/
		SEQ_GEN_CONF( SEQ_GEN_METHOD method,
		              unsigned long long length, T vmin, T vmax,
		              string split = " ", string ends = "\n" ) {
			asserti(method != METHOD_CUSTOM, "Unmatched method");
			this->method = method;
			this->length = length;
			this->vmin = vmin;
			this->vmax = vmax;
			this->split = split;
			this->ends = ends;
		}
		/**
		 * @brief SEQ_GEN_CONF ???????
		 * @param method ??????
		 * @param length ???????§Ô???
		 * @param vmin ???????§Ö???§³?
		 * @param vmax ???????§Ö?????
		 * @param eps ???????§Ö????????
		 * @param split ???????§Ö?????????????
		 * @param ends ???????§Ö????????????????
		 * @overload
		*/
		SEQ_GEN_CONF( SEQ_GEN_METHOD method,
		              unsigned long long length, T vmin, T vmax, unsigned eps,
		              string split = " ", string ends = "\n" ) {
			asserti(method != METHOD_CUSTOM, "Unmatched method");
			this->method = method;
			this->length = length;
			this->vmin = vmin;
			this->vmax = vmax;
			this->eps = eps;
			this->split = split;
			this->ends = ends;
		}
		/**
		 * @brief SEQ_GEN_CONF ???????
		 * @param method ??????
		 * @param length ???????§Ô???
		 * @param customFunction ????????????
		 * @param split ???????§Ö?????????????
		 * @param ends ???????§Ö????????????????
		 * @warning ?????????????????????????????? eps??
		*/
		SEQ_GEN_CONF( SEQ_GEN_METHOD method,
		              unsigned long long length, T (*customFunction)(int n),
		              string split = " ", string ends = "\n" ) {
			asserti(method == METHOD_CUSTOM, "Unmatched method");
			this->method = method;
			this->length = length;
			this->customFunction = customFunction;
			this->split = split;
			this->ends = ends;
		}
		SEQ_GEN_METHOD method; // ????????????
		unsigned long long length; // ????????????
		T vmin; // ??????§³????????????????????????????
		T vmax; // ???????????????????????????????????
		unsigned eps = 3; // ?????????????????????????????????????????????????? 3
		std::string split; // ??????????
		std::string ends; // ?????????????
		T (*customFunction)(int n) = nullptr; // ????????????????????????????????????????
	};

	/**
	 * @brief ????????
	 * @warning ??????????????????
	*/
	template <typename T=int>
	class Sequence
	{
		public:
			/**
			 * @brief Sequence ????????????
			*/
			Sequence() {}
			/**
			 * @brief Sequence ????????
			*/
			Sequence(SEQ_GEN_CONF<T> config) {
				SetConfig(config);
			}
			/**
			 * @brief ???????????§Û???
			 * @param config ??????ÈÉ????????? SEQ_GEN_CONF ????
			*/
			void SetConfig( SEQ_GEN_CONF<T> config ) {
				settedConfig = true;
				asserti(config.length != 0, "Invalid length");
				if(config.method == METHOD_CUSTOM) {
					isCustomGenerate = true;
					asserti(config.customFunction != nullptr, "Invalid custom generating function\'s Address.");
				} else {
					asserti(config.vmax >= config.vmin, "Invalid range");
				}
				genConfig = config;
			}
			/**
			 * @brief ???????¨À?
			 * @warning ?????????????????¦Ê??????????????????????????
			*/
			void Generate() {
				asserti(settedConfig, "No config setted yet!!");
				switch (genConfig.method) {
					case METHOD_CUSTOM: {
						CustomGen();
						break;
					}
					case METHOD_INTEGER: {
						IntegerGen();
						break;
					}
					case METHOD_FLOAT: {
						FloatGen();
						break;
					}
				}
			}
		protected:
			/**
			 * @brief ????????????
			*/
			void IntegerGen() {
				std::ofstream &cout = *rout;
				for(register int i = 1; i < int(genConfig.length); ++i) {
					cout << rnd.irand(genConfig.vmin, genConfig.vmax) << genConfig.split;
				}
				cout << rnd.irand(genConfig.vmin, genConfig.vmax) << genConfig.ends;
			}
			/**
			 * @brief ?????????????
			*/
			void FloatGen() {
				std::ofstream &cout = *rout;
				for(register int i = 1; i < int(genConfig.length); ++i) {
					cout << std::fixed << std::setprecision(genConfig.eps)
					     << rnd.frand(genConfig.vmin, genConfig.vmax)
					     << genConfig.split;
				}
				cout << rnd.frand(genConfig.vmin, genConfig.vmax) << genConfig.ends;
			}
			/**
			 * @brief ?????????????
			*/
			void CustomGen() {
				std::ofstream &cout = *rout;
				for(register int i = 1; i < int(genConfig.length); ++i) {
					cout << genConfig.customFunction(i) << genConfig.split;
				}
				cout << genConfig.customFunction(genConfig.length) << genConfig.ends;
			}
		private:
			bool settedConfig;
			bool isCustomGenerate;
			SEQ_GEN_CONF<T> genConfig;
			Random rnd;
	};

	/**
	 * @brief ????????
	*/
	class Permutation
	{
		public:
			/**
			 * @brief ???§Ö??????
			*/
			Permutation(int length) {
				id = new int[length+1];
				for(int i = 0; i <= length; i++)
					id[i] = i;
				shuffle();
			}
			/**
			 * @brief ?????????
			 * @param split ?????????????
			 * @param ends ?????????????????
			 * @warning ???split ?? ends ???????????
			*/
			void Output(string split = " ", string ends = "\n") {
				std::ofstream &cout = *rout;
				for(int i = 1; i <= length; ++i)
					cout << id[i] << split;
				cout << ends;
			}
			/**
			 * @brief ???§Ö???????????
			*/
			~Permutation() {
				delete[] id;
			}
		protected:
			/**
			 * @brief ????????
			*/
			void shuffle() {
				for(int i = 1; i <= length; ++i) {
					int oth = rnd.irand(1, length);
					std::swap(id[i], id[oth]);
				}
			}
		private:
			Random rnd;
			int *id;
			int length;
	};
}

namespace Generator
{
	using std::vector;
	using std::map;
	using std::string;
	using std::endl;

	typedef std::pair<int,int> pii;

	/**
	 * @brief ??????????›¥????????§Ö??§»?????
	*/
	class Graph
	{
		public:
			/**
			 * @brief ????????
			 * @param verCount ??????
			 * @param undirectedMap ?????????????????????false??
			 * @param weightedMap ????????????????????false??
			 * @param muiltiedgeCheck ????????????????false??
			 * @param loopCheck ?????????????????false??
			*/
			Graph( int verCount,
			       bool undirectedMap = false, bool weightedMap = false,
			       bool muiltiedgeCheck = false, bool loopCheck = false ) {
				asserti(verCount, "Invaild vertex count.");
				id = new int[ verCount + 1 ];
				vertexCount = verCount;
				undirectedMapSwitch = undirectedMap;
				muiltiedgeCheckSwitch = muiltiedgeCheck;
				weightedMapSwitch = weightedMap;
				loopCheckSwitch = loopCheck;
				clear();
			}
			/**
			 * @brief Graph ??????????????????? Graph ?????????§Û?
			*/
			~Graph() {
				delete[] id;
			}
			/**
			 * @brief ????????
			 * @warning ?????????????¦Æ??????????????????
			*/
			void clear() {
				for(register int i = 0; i <= vertexCount; ++i)
					id[i] = i;
				hashtable.clear();
				edgeContainer.clear();
			}
			/**
			 * @brief ?????????
			 * @param from ??????
			 * @param to ??????
			*/
			bool add_edge(int from, int to) {
				asserti(!weightedMapSwitch, "PANIC!! The operation doesn't match the setting.");
				if(!multiedgeChecker(from, to))
					return false;
				if(!loopChecker(from, to))
					return false;
				__add_edge(from, to);
				return true;
			}
			/**
			 * @brief ????????????
			 * @param from ??????
			 * @param to ??????
			 * @param weight ????
			*/
			bool add_edge(int from, int to, int weight) {
				asserti(weightedMapSwitch, "PANIC!! The operation doesn't match the setting.");
				if(!multiedgeChecker(from, to))
					return false;
				if(!loopChecker(from, to))
					return false;
				__add_edge(from, to, weight);
				return true;
			}
			/**
			 * @brief ????????
			 * @param shuffleOutput ????????????????
			*/
			void Output(bool shuffleOutput = true) {
				_output(shuffleOutput);
			}
			/**
			 * @brief ?????????????
			*/
			inline int GetEdgeCount() {
				return _GetEdgeCount();
			}
		protected:
			int *id;
			/**
			 * @brief ????????????
			*/
			inline int _GetEdgeCount() {
				return edgeContainer.size();
			}
			/**
			 * @brief ?????????
			 * @param shuffleOutput ?????????????????????true??
			*/
			void _output(bool shuffleOutput = true) {
				std::ofstream &cout = *rout;
				if(shuffleOutput)
					shuffle();
				for(auto c : edgeContainer) {
					if(weightedMapSwitch)
						cout << id[c.from] << ' '
						     << id[c.to] << ' '
						     << c.weight << endl;
					else
						cout << id[c.from] << ' '
						     << id[c.to] << endl;
				}
			}
			/**
			 * @brief ???????
			*/
			void shuffle() {
				Random rnd;
				for(int i = 1; i <= vertexCount; ++i) {
					int oth = rnd.irand(1, vertexCount);
					std::swap(id[i], id[oth]);
				}
				std::shuffle(edgeContainer.begin(), edgeContainer.end(), std::mt19937_64(time(0)));
			}
			/**
			 * @brief ??????????????
			*/
			inline void __add_edge(int from, int to, int weight) {
				edgeContainer.push_back( (EDGE) {
					from, to, weight
				} );
			}
			/**
			 * @brief ??????????????
			*/
			inline void __add_edge(int from, int to) {
				edgeContainer.push_back( (EDGE) {
					from, to, 1
				} );
			}
			/**
			 * @brief ???????
			 * @return true ???????????false ?????????
			 * @note ??????????????????
			*/
			inline bool multiedgeChecker(int from, int to) {
				if(!muiltiedgeCheckSwitch)
					return true;
				if(from > to && undirectedMapSwitch)
					std::swap(from,to);
				if(hashtable[ {from, to}]) {
					fprintf(stderr, "Edge <%d,%d> was unable to pass muiltiedge check. Ignored.\n", from, to);
					return false;
				}
				hashtable[ {from, to}] = true;
				return true;
			}
			/**
			 * @brief ????????
			 * @return true ???????????false ?????????
			 * @note ??????????????????
			*/
			inline bool loopChecker(int from, int to) {
				if(!loopCheckSwitch)
					return true;
				if(from == to) {
					fprintf(stderr, "Edge <%d,%d> was unable to pass loop check. Ignored.\n", from, to);
					return false;
				}
				return true;
			}
		private:
			bool loopCheckSwitch;
			bool muiltiedgeCheckSwitch;
			bool undirectedMapSwitch;
			bool weightedMapSwitch;
			int vertexCount;
			struct EDGE {
				int from, to, weight;
			};
			vector<EDGE> edgeContainer;
			map<pii,bool> hashtable;
	};

	/**
	 * @brief ???????????
	*/
	enum NRT_GEN_CONF {
	    METHOD_DAISY=5, //?????????
	    METHOD_CHAIN=10, //?????????
	    METHOD_CHAIN_WITH_CHAIN=25, //??????????
	    METHOD_DAISY_WITH_DAISY=40, //??????????
	    METHOD_CHAIN_WITH_DAISY=60, //??????????
	    METHOD_COMP_KB_TREE=75, //???????K????
	    METHOD_RND_TREE=90, //?????????
	    METHOD_TREE_OVER_TREE=100 //????????????????
	};

	/**
	 * @brief ????????????
	*/
	class NoRootTree : protected Graph
	{
		public:
			/**
			 * @brief NoRootTree ????????????
			 * @param verCount ????
			 * @param vmin ?????§³?
			 * @param vmax ???????
			 * @warning ????¨´???????????????????§Ò?????
			*/
			NoRootTree(int verCount, int vmin, int vmax)
				:Graph(verCount, true, true, true, true) {
				vertexCount = verCount;
				weightedTreeSwitch = true;
				this->vmin = vmin;
				this->vmax = vmax;
				clear();
			}
			/**
			 * @brief NoRootTree ????????????
			 * @param verCount ????
			 * @warning ????¨´???????????????????§Ò?????
			*/
			NoRootTree(int verCount)
				:Graph(verCount, true, false, true, true) {
				vertexCount = verCount;
				weightedTreeSwitch = false;
				clear();
			}
			/**
			 * @brief ???????????????
			*/
			void Generate() {
				clear();
				int mode = rnd.irand(1, 100);
				_Generate(mode);
			}
			/**
			 * @brief ???????????????
			*/
			void SpecificGenerate(NRT_GEN_CONF tgc) {
				clear();
				_Generate(tgc);
			}
			/**
			 * @brief ?????????
			*/
			void Output(bool shuffleOutput = true) {
				this->_output(shuffleOutput);
			}
		protected:
			/**
			 * @brief ???????????????????
			 * @param from ??????
			 * @param to ??????
			*/
			void add(int from, int to) {
				if(weightedTreeSwitch)
					add_edge(from, to, rnd.irand(vmin, vmax));
				else
					add_edge(from, to);
			}
			/**
			 * @brief ???????????
			*/
			void _Generate(int mode) {
				if(mode<=5)
					Daisy();
				else if(mode <= 10)
					Chain();
				else if(mode <= 25)
					ChainWithChain();
				else if(mode <= 40)
					DaisyWithDaisy();
				else if(mode <= 60)
					ChainWithDaisy();
				else if(mode <= 75)
					CompleteKBTree();
				else if(mode <= 90)
					RandomTree();
				else
					TreeOverTree();
			}
			/**
			 * @brief ?????????
			 * @param center ????????
			 * @param size ?????§³
			 * @param labelbegin ????????????
			*/
			void Daisy(int center = 1, unsigned size = 0, int labelbegin = 1) {
				if(!size)
					size = vertexCount;
				for(int i = labelbegin; i < labelbegin+int(size); ++i)
					add(center, i);
			}
			/**
			 * @brief ?????????
			 * @param begin ??????????
			 * @param length ???????
			 * @param labelbegin ???????????
			 * @warning ???labelbegin ?? begin ??§Û??
			*/
			void Chain(int begin = 1, unsigned length = 0, int labelbegin = 1) {
				if(!length)
					length = vertexCount;
				add(begin, labelbegin);
				for(int i = labelbegin; i < labelbegin + int(length) - 1; ++i) {
					add(i, i+1);
				}
			}
			/**
			 * @brief ??????????
			 * @param ChainProbability ???????????
			 * @param DaisyProbability ???????????
			 * @warning ???????????????????????? 1
			 * @warning ????????????????????
			*/
			void ChainWithDaisy( double ChainProbability=0.5,
			                     double DaisyProbability=0.5 ) {
				asserti(ChainProbability + DaisyProbability == 1, "PANIC!!! Probability sum wasn't equal to 1.");
				int bsize = sqrt(vertexCount);
				int i = 1;
				for(i = 2; i+bsize-1 <= vertexCount; i += bsize) {
					double mode = rnd.frand(0, 1);
					int p = rnd.irand(1, i-1);
					if(mode <= ChainProbability)
						Chain(p, bsize, i);
					else
						Daisy(p, bsize, i);
				}
				if(i-1 < vertexCount) {
					double mode = rnd.frand(0, 1);
					int p = rnd.irand(1, i-1);
					if(mode <= ChainProbability)
						Chain(p, vertexCount-i+1, i);
					else
						Daisy(p, vertexCount-i+1, i);
				}
			}
			/**
			 * @brief ??????????
			*/
			void ChainWithChain() {
				int bsize = sqrt(vertexCount);
				int i = 1;
				for(i = 2; i+bsize-1 <= vertexCount; i += bsize) {
					int p = rnd.irand(1, i-1);
					Chain(p, bsize, i);
				}
				if(i-1 < vertexCount) {
					int p = rnd.irand(1, i-1);
					Chain(p, vertexCount-i+1, i);
				}
			}
			/**
			 * @brief ??????????
			*/
			void DaisyWithDaisy() {
				int bsize = sqrt(vertexCount);
				int i = 0;
				for(i = 2; i+bsize-1 <= vertexCount; i += bsize) {
					int p = rnd.irand(1, i-1);
					Daisy(p, bsize, i);
				}
				if(i-1 < vertexCount) {
					int p = rnd.irand(1, i-1);
					Daisy(p, vertexCount-i+1, i);
				}
			}
			/**
			 * @brief ????????????????
			 * @param beginlabel ???????????
			 * @param endlabel ???????????
			*/
			void RandomTree(int beginlabel = 1, int endlabel = 0) {
				if(!endlabel)
					endlabel = vertexCount;
				for(int i = beginlabel+1; i <= endlabel; i++) {
					int from = rnd.irand(beginlabel, i-1);
					add(from, i);
				}
			}
			/**
			 * @brief ?????????? K ????
			*/
			void CompleteKBTree() {
				int k = rnd.irand(2, 5);
				for(int i = 2; i <= vertexCount; ++i) {
					if(weightedTreeSwitch)
						add_edge(i, ((k - 2) + i) / k, rnd.irand(vmin, vmax));
					else
						add_edge(i, ((k - 2) + i) / k);
				}
			}
			/**
			 * @brief ????????????????????????
			*/
			void TreeOverTree() {
				int bsize = sqrt(vertexCount);
				int i = 0;
				for(i = 1; i+bsize <= vertexCount; i += bsize)
					RandomTree(i, i+bsize);
				if(i < vertexCount)
					RandomTree(i);
			}
		private:
			bool weightedTreeSwitch;
			int vertexCount;
			int tot = 0;
			int vmin, vmax;
			Random rnd;
	};

	/**
	 * @brief ????????
	*/
	class DaisyChain : protected Graph
	{
		public:
			/**
			 * @brief ??? DaisyChain ???????
			 * @param verCount ???????????
			*/
			DaisyChain(int verCount)
				:Graph(verCount, false, false, true, true) {
				vertexCount = verCount;
				weightedDaisyMapSwitch = false;
			}
			/**
			 * @brief ??? DaisyChain ???????
			 * @param vmin ?????§³?
			 * @param vmax ???????
			*/
			DaisyChain(int verCount, int vmin, int vmax)
				:Graph(verCount, false, true, true, true) {
				vertexCount = verCount;
				weightedDaisyMapSwitch = true;
				vmax = vmax;
				vmin = vmin;
			}
			/**
			 * @brief ????????
			*/
			void Generate() {
				clear();
				for(int i = 2; i <= vertexCount ; ++i)
					add(central, i);

				for(int i = vertexCount; i >= 2; --i)
					add(i, i-1);
			}
			/**
			 * @brief ?????????
			*/
			void Output(bool shuffleOutput = true) {
				_output(shuffleOutput);
			}
		protected:
			/**
			 * @brief ???????????????????
			 * @param from ??????
			 * @param to ??????
			*/
			void add(int from, int to) {
				if(weightedDaisyMapSwitch)
					add_edge(from, to, rnd.irand(vmin, vmax));
				else
					add_edge(from, to);
			}
		private:
			bool weightedDaisyMapSwitch;
			int vertexCount;
			int vmin, vmax;
			int central = 1;
			Random rnd;
	};

	/**
	 * @brief ???????? SPFA ??????????
	*/
	class AntiSPFA : protected Graph
	{
		public:
			/**
			 * @brief AntiSPFA ??????
			 * @param n ????? n ??
			 * @param m ????? m ??
			*/
			AntiSPFA(int n, int m)
				:Graph(n*m, false, true, true, true) {
				this->n = n;
				this->m = m;
				this->vmin = vmin;
				this->vmax = vmax;
			}
			/**
			 * @brief ??????
			*/
			inline int GetStart() {
				return id[1];
			}
			/**
			 * @brief ???????
			*/
			inline int GetEdgeCount() {
				return _GetEdgeCount();
			}
			/**
			 * @brief ????????
			 * @param vmin ?????§³?
			 * @param vmax ???????
			*/
			void Generate(int vmin, int vmax) {
				clear();
				shuffle();
				for(int i = 1; i <= n; ++i) {
					for(int j = 1; j < m; ++j) {
						add_edge(getIndex(i, j), getIndex(i, j+1), rnd.irand(vmin, vmax));
						add_edge(getIndex(i, j+1), getIndex(i, j), rnd.irand(vmin, vmax));
					}
				}
				for(int i = 1; i <= m; ++i) {
					for(int j = 1; j < n; ++j) {
						add_edge(getIndex(j, i), getIndex(j+1, i), 1);
						add_edge(getIndex(j+1, i), getIndex(j, i), 1);
					}
				}
				for(int i = 1; i < n; ++i)
					for(int j = 1; j < m; ++j)
						add_edge(getIndex(i, j), getIndex(i+1, j+1), rnd.irand(vmin, vmax));
			}
			/**
			 * @brief ?????????????
			 * @param vmin ?????§³?
			 * @param vmax ???????
			*/
			inline void AutoMode(int vmin, int vmax) {
				std::ofstream &cout = *rout;
				cout << n*m << ' ' << GetEdgeCount() << ' ' << GetStart() << endl;
				Generate(vmin, vmax);
				Output();
			}
			/**
			 * @brief ?????????
			*/
			void Output() {
				_output(false);
			}
		protected:
			/**
			 * @brief ???????????????????????§Ö????›¥¦Ë??\
			 * @param i ?? i ??
			 * @param j ?? j ??
			*/
			inline int getIndex(int i, int j) {
				return (i-1)*m+j;
			}
		private:
			int n,m;
			int vmin, vmax;
			Random rnd;
	};

	/**
	 * @brief ????????
	 * @note ????????????????????????????
	*/
	class RandomGraph : protected Graph
	{
		public:
			/**
			 * @brief ??????????????
			 * @param verCount ????????
			 * @param edgeCount ????????
			 * @param undirectedMap ?????????????????????false??
			 * @warning ???????????????????????????????????????????????????????
			*/
			RandomGraph(int verCount, int edgeCount, bool undirectedMap = false)
				:Graph(verCount, undirectedMap, false, true, true),
				 vertexCount(verCount), edgeCount(edgeCount),
				 weightedMapSwitch(false) {
			}
			/**
			 * @brief ??????????????
			 * @param verCount ????????
			 * @param edgeCoucnt ????????
			 * @param vmin ?????§³?
			 * @param vmax ???????
			 * @param undirectedMap ?????????????????????false??
			 * @warning ???????????????????????????????????????????????????????
			*/
			RandomGraph( int verCount, int edgeCount, int vmin, int vmax,
			             bool undirectedMap = false)
				:Graph(verCount, undirectedMap, true, true, true),
				 vertexCount(verCount), edgeCount(edgeCount),
				 vmin(vmin), vmax(vmax),
				 weightedMapSwitch(true) {
			}
			/**
			 * @brief ????????
			*/
			void Generate() {
				while(edgeCount) {
					bool u = rnd.irand(1, vertexCount);
					bool v = rnd.irand(1, vertexCount);
					edgeCount -= add(u, v);
				}
			}
			/**
			 * @brief ?????????
			 * @param shuffleOutput ????????????????????true??
			*/
			void Output(bool shuffleOutput = true) {
				_output(shuffleOutput);
			}
		protected:
			/**
			 * @brief ???????????????????
			 * @param from ??????
			 * @param to ??????
			*/
			bool add(int from, int to) {
				if(weightedMapSwitch)
					return add_edge(from, to, rnd.irand(vmin, vmax));
				else
					return add_edge(from, to);
			}
		private:
			Random rnd;
			int vertexCount;
			int edgeCount;
			int vmin, vmax;
			bool weightedMapSwitch;
	};

	/**
	 * @brief ?????????????????
	*/
	class DAG : protected Graph
	{
		public:
			/**
			 * @brief ??????????????????
			 * @param verCount ?????????????
			 * @param edgeCount ?????????????
			*/
			DAG(int verCount, int edgeCount)
				:Graph(verCount, false, false, true, true),
				 vertexCount(verCount), edgeCount(edgeCount),
				 weightedMapSwitch(false) {
				asserti(edgeCount >= verCount - 1, "Invalid edge count.");
			}
			/**
			 * @brief ??????????????????
			 * @param verCount ?????????????
			 * @param edgeCount ?????????????
			 * @param vmin ?????§³?
			 * @param vmax ???????
			*/
			DAG(int verCount, int edgeCount, int vmin, int vmax)
				:Graph(verCount, false, true, true, true),
				 vertexCount(verCount), edgeCount(edgeCount),
				 vmin(vmin), vmax(vmax),
				 weightedMapSwitch(true) {
				asserti(edgeCount >= verCount - 1, "Invalid edge count.");
			}
			/**
			 * @brief ????????
			*/
			void Generate() {
				for(int i = 2; i <= vertexCount; i++) {
					int from = rnd.irand(1, i-1);
					add(from, i);
				}
				edgeCount -= vertexCount - 1;
				if(!edgeCount)
					return ;
				for(int i = 1; i <= vertexCount; ++i) {
					for(int j = i+1; j <= vertexCount; ++j) {
						if(!edgeCount)
							return;
						edgeCount -= add(i, j);
					}
				}
			}
			/**
			 * @brief ?????????
			 * @param shuffleOutput ????????????????????true??
			*/
			void Output(bool shuffleOutput = true) {
				_output(shuffleOutput);
			}
		protected:
			/**
			 * @brief ???????????????????
			 * @param from ??????
			 * @param to ??????
			*/
			bool add(int from, int to) {
				if(weightedMapSwitch)
					return add_edge(from, to, rnd.irand(vmin, vmax));
				else
					return add_edge(from, to);
			}
		private:
			int vertexCount;
			int edgeCount;
			int vmin, vmax;
			bool weightedMapSwitch;
			Random rnd;
	};
	/**
	 * @brief ?????????????
	 * @note ????????§Ó?????????????????????????/kk
	 * @warning ??????????¡Â??????????? BUG
	*/
	class Cactus
	{
		public:
			/**
			 * @brief ??? Cactus ???????
			 * @param verCount ?????
			*/
			Cactus(int verCount) {
				vertexCount = verCount;
				weightedMapSwitch = false;
				alloc(verCount);
				clear();
			}
			/**
			 * @brief ??? Cactus ???????
			 * @param verCount ?????
			 * @param vmin ?????§³?
			 * @param vmax ???????
			*/
			Cactus(int verCount, int vmin, int vmax)
				:vmin(vmin), vmax(vmax) {
				vertexCount = verCount;
				weightedMapSwitch = true;
				alloc(verCount+1);
				clear();
			}
			/**
			 * @brief Cactus ??????????
			*/
			~Cactus() {
				delete[] head;
				delete[] ver;
				delete[] next;
				delete[] edge;
				delete[] top;
				delete[] siz;
				delete[] fa;
				delete[] hson;
				delete[] id;
			}
			/**
			 * @brief ??? Cactus
			*/
			void clear() {
				tot = 0;
				memset(top,-1,sizeof(int)*(vertexCount<<2));
				memset(next, 0, sizeof(int)*(vertexCount<<2));
				memset(head, 0, sizeof(int)*vertexCount);
				memset(ver, 0, sizeof(int)*(vertexCount<<2));
				memset(edge, 0, sizeof(int)*(vertexCount<<2));
				memset(siz, 0, sizeof(int)*(vertexCount<<2));
				memset(fa, 0, sizeof(int)*(vertexCount<<2));
				memset(hson, 0, sizeof(int)*(vertexCount<<2));
				for(int i = 1; i <= vertexCount; ++i)
					id[i] = i;
			}
			/**
			 * @brief ????????
			*/
			void Generate() {
				for(int i = 2; i <= vertexCount; i++) {
					int from = rnd.irand(1, i-1);
					add(from, i);
				}
				TreeDecomposition();
				for(int i = 1; i <= vertexCount; ++i) {
					if(top[i] != -1)
						add(i, top[i]);
				}
			}
			/**
			 * @brief ?????????
			 * @param shuffleOutput ????????????????????true??
			*/
			void Output(bool shuffleOutput = true) {
				_output(shuffleOutput);
			}
		protected:
			void alloc(int verCount) {
				head = new int[verCount];
				next = new int[verCount<<2];
				ver = new int[verCount<<2];
				edge = new int[verCount<<2];
				top = new int[verCount<<2];
				siz = new int[verCount<<2];
				fa = new int[verCount<<2];
				hson = new int[verCount<<2];
				id = new int[verCount];
			}
			/**
			 * @brief ???????
			*/
			void TreeDecomposition() {
				dfs1(1, 1);
				dfs2(1, 1);
			}
			/**
			 * @brief ????????????
			 * @param u ??????
			 * @param f ???????????
			*/
			void dfs1(int u, int f) {
				siz[u] = 1;
				fa[u] = f;
				int maxsize = -1;
				for(int i = head[u]; i; i = next[i]) {
					int v = ver[i];
					if(v == f)
						continue;
					dfs1(v, u);
					siz[u] += siz[v];
					if(maxsize < siz[v]) {
						hson[u] = v;
						maxsize = siz[v];
					}
				}
			}
			/**
			 * @brief ???????
			 * @param u ??????
			 * @param t ????
			*/
			void dfs2(int u, int t) {
				if(!hson[u]) {
					top[u] = t;
					return;
				}
				dfs2(hson[u], t);
				for(int i = head[u]; i; i = next[i]) {
					int v = ver[i];
					if(v != hson[u] && v != fa[u])
						dfs2(v, v);
				}
			}
			/**
			 * @brief ???????????????????
			 * @param from ??????
			 * @param to ??????
			*/
			void add(int from, int to) {
				if(weightedMapSwitch)
					add_edge(from, to, rnd.irand(vmin, vmax));
				else
					add_edge(from, to);
			}
			/**
			 * @brief ????????????????
			 * @param from ??????
			 * @param to ??????
			*/
			void add_edge(int from, int to) {
				_add_edge(from, to);
				_add_edge(to, from);
			}
			/**
			 * @brief ???????????????
			 * @param from ??????
			 * @param to ??????
			 * @param weight ???
			*/
			void add_edge(int from, int to, int weight) {
				_add_edge(from, to, weight);
				_add_edge(to, from, weight);
			}
			/**
			 * @brief ????????????????
			 * @param from ??????
			 * @param to ??????
			*/
			void _add_edge(int from, int to) {
				ver[++tot] = to;
				next[tot] = head[from];
				head[from] = tot;
			}
			/**
			 * @brief ???????????????
			 * @param from ??????
			 * @param to ??????
			 * @param weight ???
			*/
			void _add_edge(int from, int to, int weight) {
				ver[++tot] = to;
				edge[tot] = weight;
				next[tot] = head[from];
				head[from] = tot;
			}
			/**
			 * @brief ????????
			*/
			void shuffle() {
				Random rnd;
				for(int i = 1; i <= vertexCount; ++i) {
					int oth = rnd.irand(1, vertexCount);
					std::swap(id[i], id[oth]);
				}
			}
			/**
			 * @brief ?????????
			*/
			void _output(bool shuffleOutput = true) {
				std::ofstream &cout = *rout;
				if(shuffleOutput)
					shuffle();
				for(int i = 1; i <= vertexCount; ++i) {
					for(int j = head[i]; j; j = next[j]) {
						int v = ver[j];
						if(hashtable[ { std::min(i, v), std::max(i, v) }])
							continue;
						cout << id[v] << ' ' << id[i];
						if(weightedMapSwitch)
							cout << ' ' << edge[i];
						cout << std::endl;
						hashtable[ { std::min(i, v), std::max(i, v) }] = true;
					}
				}
			}
		private:
			bool weightedMapSwitch;
			int vertexCount;
			int *head, *next, *ver, *edge;
			int *siz, *hson, *top, *fa;
			int *id;
			int vmin, vmax;
			int tot = 0;
			Random rnd;
			map<pii,bool> hashtable;
	};
}

#endif
